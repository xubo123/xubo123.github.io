---
layout:     post
title:      "LeetCode题目思路整理"
subtitle:   "LeetCode"
date:       2018-05-14 15:00:00
author:     "Xu"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - LeetCode
---

# LeetCode刷题思路

**LeetCode**


主要tag：数组、字符串、链表、树、栈、队列、动态规划、哈希表、二分查找

题目分类：

* [数据搜索和查找（哈希表，二分法）](#数据搜索及查找)
* [动态规划](#动态规划)
* [递归](#递归)
* [位运算,数学边界问题](#位运算,数学边界问题)
* [数据分类](#数据分类)
* [其它](#其它)

|  #   |  Title  |        Solution        | Difficulty | Tag  |
| :--: | :-----: | :--------------------: | :--------: | :--: |
|  1   |  两个排序数组的中位数 | [O](#leetcode4) |    Hard    | 数组 \| 数据搜索|
|  5   | 最长回文子串 | [O](#leetcode5) |    Medium    | 字符串 \| 动态规划 |
|  7   | 反转整数 | [O](#leetcode7) |    Easy    | 数学 \| 其他 |
|  8   | 字符串转整数 | [O](#leetcode8) |    Medium    | 字符串 |
|  10 | 字符串常规匹配 | [O](#leetcode10) |    Hard    | 字符串 \| 递归 \|动态规划 |
|  11 | 盛最多水的容器 | [O](#leetcode11) |    Medium    | 数组 |
|  13 | 罗马数字转整数 | [O](#leetcode13) |    Easy    | 字符串 |
|  15 | 三数之和 | [O](#leetcode15) |    Medium    | 数组 \| 两点法 |
|  17 | 电话号码的字母组合 | [O](#leetcode17) |    Medium    | 字符串 \| 递归|
|  20 | 有效的括号 | [O](#leetcode20) |    Easy    | 字符串 \| 回溯法 |
|  21 | 合并两个有序链表 | [O](#leetcode21) |    Easy    | 链表 \| 优先级队列 \| 归并法 |
|  29   | 两数相除 | [O](#leetcode29) |    Medium    | 数学 \| 位运算|
|  33   | 搜索旋转排序数组 | [O](#leetcode33) |    Medium    | 数组 \| 二分查找 |
|  34   | 搜索范围 | [O](#leetcode34) |    Medium    | 数组 \| 二分查找 |
| 35 | 搜索插入位置 | [O](#leetcode35) | Easy | 数组 \| 二分查找 |
| 36 | 有效的数读独 | [O](#leetcode36) | Medium | 数组 \| 哈希表 |
| 38 | 报数 | [O](#leetcode38) | Easy | 数学 |
| 41 | 寻找第一个未出现的正数 | [O](#leetcode41) | Medium | 数组 \| 哈希表 |
| 42 | 容器可以装多少水 | [O](#leetcode42) | Medium | 数组 \| 动态规划 \|两点法|
| 44 | 字符串匹配2 | [O](#leetcode44) |    Hard    | 字符串 \| 递归 \|动态规划 |
| 48 | 旋转图形 | [O](#leetcode48) | Medium | 数组 \| 递归 |
| 49 | 字符串分类 | [O](#leetcode49) | Medium | 数组 \| 哈希表，索引|
| 50 | 求幂Pow(x, n) | [O](#leetcode50) | Medium | 数学 \| 位运算|
| 53 | 最大子序和 | [O](#leetcode53) | Easy | 数组 \| 动态规划 |
| 54 | 旋转打印矩阵 | [O](#leetcode54) | Medium | 数组 \| 递归 |
| 55 | 跳跃游戏 | [O](#leetcode55) | Medium | 数组 \| 其它 |
| 56 | 区间合并 | [O](#leetcode56) | Medium | 数组 \| 其它 |
| 62 | 机器人走格子路径 | [O](#leetcode62) | Medium | 数组 \| 动态规划 |
| 69 | 求平方根 | [O](#leetcode69) | Easy | 数学 \| 边界 |
| 73 | 设置矩阵0行和列 | [O](#leetcode73) | Medium | 数组 \| 哈希表 |
| 75 | 颜色排序 | [O](#leetcode75) | Medium | 数组 \| 两点法 |

## 数据搜索及查找

(哈希表,二分法)

### LeetCode4

#### 如何找到两个排序数组的中位数？(LeetCode4:Median of Two Sorted Arrays)

* 描述：给定两个排序的数组a，b长度分别为m，n找出这两个数组的中位数，时间复杂度为O(log(m+n))

假定a,b长度分别大于k，现在选择第k个数（排序后第k个数），先将a的第k/2个元素（a[k/2-1]）和b的第k/2个数进行比较，存在以下三种情况：

1. a[k/2-1] == b[k/2-1],第k个数找到了，就是a[k/2-1]或b[k/2-1]
2. a[k/2-1] > b[k/2-1],第k大的数肯定不可能在b[0..k/2-1]之间，因为小于b[k/2-1]的数包括b[0..k/2-1]（k/2个）以及a[0..k/2-1]（小于k/2个）中的一部分
3. 同上，a[k/2-1] < b[k/2-1],第k大的数肯定不可能在a[0..k/2-1]之间

要是m,n其中有一个长度小于k/2,则取长度和k/2的较小值来进行切割。

### LeetCode33

#### 在翻转数组中查找指定数据（LeetCode33: Search in Rotated Sorted Array）

翻转数组在剑指offer中有相关描述，这题也是剑指offer面试题11的很好的延伸，思路利用二分法来进行数据搜索，需要注意的是，如何根据nums[mid]和查找目标target的大小关系进行范围的缩小，分为两种情况：

{% highlight c++ %}

class Solution {
public:
    int search(vector<int>& nums, int target) {
        if(nums.empty()){
            return -1;
        }
        int low = 0,high = nums.size()-1,mid = 0;
        while(low < high){
            mid = (low+high)/2;
            //情况1:中切节点后面的部分不为递增数列
            if(nums[mid]>nums[high]){
                if(nums[mid] > target){
                    if(target > nums[high]){
                        high = mid -1;
                    }else if((target < nums[high])){
                        low = mid + 1;
                    }else {
                        return high;
                    }     
                }else if(nums[mid] < target){
                    low = mid + 1;
                }else{
                    return mid;
                }
            }else if(nums[mid]<=nums[high] ){
            // 情况2:中切节点后面的部分为递增序列
                if(nums[mid] > target){
                    high = mid -1;
                }else if(nums[mid] < target){
                    if(target > nums[high]){
                        high = mid - 1;
                    }else if(target < nums[high]){
                        low = mid +1;
                    }else{
                        return high;
                    }

                }else{
                    return mid;
                }
            }
        }
        //确定最后一个元素是否等于target
        if(nums[low] == target)
            return low;
        
        return -1;
        
    }
};

{% endhighlight %}

### LeetCode34

#### 搜索一个数字在一个递增数组（允许数字重复）中出现的范围(LeetCode34:Search for a Range)

返回出现的下标范围［start ，end］，如果不存在返回［-1,-1］

思路：二分法

{% highlight c++ %}
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        int low = 0,high = nums.size()-1;
        int mid;
        int start = -1, end = -1;
        vector<int> result;
        if(nums.empty()){
            result.push_back(start);
            result.push_back(end);
            return result;
        }
        //开始二分查找，只要找到就返回
        while(low<high){
            mid = (low+high)/2;
            if(nums[mid] > target){
                high = mid -1;
            }else if(nums[mid] < target){
                low = mid + 1;
            }else{
                start = end = mid;
                break;
            }
        }
        //查看最后的位置是否即为目标数
        if(nums[low] == target){
            start = end = low;
        }
        //确定前后范围
        if(start >= 0){
            while(start>0){
                if(nums[start-1] == target)
                    start--;
                else
                    break;
            }
            
            while(end < nums.size()-1){
                if(nums[end+1] == target)
                    end++;
                else 
                    break;
            }
        }

        result.push_back(start);
        result.push_back(end);
        return result;
    }
};

{% endhighlight %}


### LeetCode36

#### 判断数独二维数组是否合法(LeetCode36: Valid Sudoku)

* 为什么要把这一题放到数据搜索及查找这一分类？因为判断一个数独数组是否合法可以分解为在纵向列，横向行，及每个子box中寻找重复的数字（1-9），只要有重复的数字就不合法，没有就合法。
* 而寻找重复的数字在剑指offer中有对应的题目：**面试题3，哈希表的思路**

我先介绍自己的思路：利用**三个map**保存每一行，每一列，每个子box是否有效，然后逐个字符来进行判断。

{% highlight c++ %}

class Solution {
public:
    bool isValidSudoku(vector<vector<char>>& board) {
        map<int,bool> row_map,column_map,box_map;//三个记录每行，每列，每个子 box是否合法的map
        set<char> test_set;
        
        //初始化
        for(int i = 0;i<9;i++){
            row_map.insert(make_pair(i,false));
            column_map.insert(make_pair(i,false));
            box_map.insert(make_pair(i,false));
        }
        //循环遍历二维数组中的每个元素
        for(int i = 0;i<9;i++){
            for (int j = 0;j<9;j++){
                
                //对于每一个元素，先测试所在行是否合法
                if (board[i][j]!='.'){
                    if(!column_map[i]){
                        //还没被测试过，开始测试，如果已经测试为真，则直接跳过
                        for(int k = j;k<9;k++){
                            if(board[i][k]!='.'){
                                if(test_set.count(board[i][k])){
                                    return false;
                                }else{
                                    test_set.insert(board[i][k]);
                                }
                            }
                        }
                        column_map[i] = true;
                    }
                    
                    test_set.clear();//清楚测试集，用于下一个测试

                    //开始测试所在列是否合法，若之前已经被测试过，则直接跳过
                    if(!row_map[j]){
                        //还没测试过，开始检查
                        for(int k = i;k<9;k++){
                            if(board[k][j]!='.'){
                                if(test_set.count(board[k][j])){
                                    return false;
                                }else{
                                    test_set.insert(board[k][j]);
                                }
                            }
                        }
                        row_map[j] = true;
                    }
                    
                    test_set.clear();
                    int index = (i/3)*3 + j/3;
                    //开始测试所在子box是否合法
                    if(!box_map[index]){
                        //开始检查
                        int start_col = (index/3)*3;
                        int start_row = (index%3)*3;
                        for(int col = start_col;col<start_col+3;col++){
                            for(int row = start_row;row<start_row+3;row++){
                                if(board[col][row]!='.'){
                                    if(test_set.count(board[col][row])){
                                        return false;
                                    }else{
                                        test_set.insert(board[col][row]);
                                    }
                                }
                            }
                        }
                        box_map[index] = true;
                    }
                    test_set.clear();
                }
                
            }
        }
        //当所有元素遍历检查结束后没出现不合法情况，则合法
        return true;
        
    }
};

{% endhighlight %}

**哈希表**的思路：分别创建用于测试行，列，子box的三个二维哈希表。

{% highlight c++ %}

class Solution
{
public:
    bool isValidSudoku(vector<vector<char> > &board)
    {
        int used1[9][9] = {0}, used2[9][9] = {0}, used3[9][9] = {0};//三个用于测试的哈希表，初始化为0
        
        for(int i = 0; i < board.size(); ++ i)
            for(int j = 0; j < board[i].size(); ++ j)
                if(board[i][j] != '.')
                {
                    int num = board[i][j] - '0' - 1, k = i / 3 * 3 + j / 3;
                    if(used1[i][num] || used2[j][num] || used3[k][num])
                    //所在位置出现重复，说明所在行，所在列或所在子box有重复的元素，不合法
                        return false;
                    used1[i][num] = used2[j][num] = used3[k][num] = 1;//之前没出现过则将该数值存放到行，列，子box三个哈希表中和数值相等的下标的位置上去。
                }
        
        return true;
    }
};


{% endhighlight %}

### LeetCode41

#### 找到第一个未出现的正数（LeetCode41: First Missing Positive）

* 描述：给出一个未排序的整型数组（元素可以重复），找出所有正数1,2,3...开始第一个没出现在该数组中的元素

如：
* \[ 1,2,0 \]:输出3
* \[ -1,3,4,1 \]:输出2

思路： 哈希表，将自身当作一个hash表，遍历这个数组，将每一个数放置到该数对应的下标上去
如果：

    - 出现该数对应的下标超出该数组的范围或者该数为非正数，则和尾部**第一个没有超出**数组大小的数进行互换，互换后尾部的数据则**不用考虑**，且**需要检测**的数组的大小也对应缩小
    - 该数对应的下标的位置上已经有正确的数(**重复**)，同样和数组尾部第一个没有超出数组大小的数进行互换，互换后尾部的数据则不用考虑，且需要检测的数组的大小也对应缩小

所有的数正确安排结束后，则开始从头开始遍历，第一个和下标不能一一对应的数就是第一个没有出现的正数，返回

{% highlight c++ %}

class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        if(nums.empty()){
            return 1;
        }
        int size = nums.size();
        int tmp;
        int end = size;
        for(int i = 0;i<end;i++){
            if(nums[i] != i+1){
                if(nums[i] <= 0||nums[i] > end|| nums[nums[i]-1] == nums[i]){//需要放置到尾部不予考虑
                    while(end-1 > i && nums[end-1] >= end){
                        end--;//在尾部找到第一个合法的数
                    }
                    if(end-1>i){
                        tmp = nums[end-1];
                        nums[end-1] = nums[i];
                        nums[i] = tmp;
                        i--;
                        end--;
                    }
                }else {
                //放置到正确的下标位置
                    tmp = nums[nums[i]-1];
                    nums[nums[i]-1] = nums[i];
                    nums[i] = tmp;
                    i--;
                }
            }
        }
        
        int k = 0;
        while(k<size && nums[k] == k+1){
            k++;//遍历得到第一个没有出现的正数
        }
        return k+1;
    }
};

{% endhighlight %}

### LeetCode73

#### 设置矩阵0项的行和列（LeetCode73:Set Matrix Zeroes）

给出一个二维矩阵，对于该矩阵中的每一个为0的元素，将其所在的行和列全部设为0。

```
Input: 
[
  [1,1,1],
  [1,0,1],
  [1,1,1]
]
Output: 
[
  [1,0,1],
  [0,0,0],
  [1,0,1]
]

Input: 
[
  [0,1,2,0],
  [3,4,5,2],
  [1,3,1,5]
]
Output: 
[
  [0,0,0,0],
  [0,4,5,0],
  [0,3,1,0]
]
```

思路：哈希表。一个矩阵一共有m行，n列，每一行和每一列我们都需要了解其是否应该被设置为0的信息。将这个信息和它们所在的行列下标联系起来:

* 所以我们可以用**第一行**的元素 matrix[0][j]来记录所有列是否该设为0，若需要，则将第一行对应列的元素也设为0。
* 对于行是否该设为0 的信息则保存在**第一列**中
* 但由于第一行和第一列的信息**发生重合**，所以我们将第一行的信息，保存在额外的变量**col0**中

代码实现：

```c++
void setZeroes(vector<vector<int> > &matrix) {
    int col0 = 1, rows = matrix.size(), cols = matrix[0].size();

    for (int i = 0; i < rows; i++) {//将每一行和每一列是否该设置为0的信息保存在对应的位置
        if (matrix[i][0] == 0) col0 = 0;
        for (int j = 1; j < cols; j++)
            if (matrix[i][j] == 0)
                matrix[i][0] = matrix[0][j] = 0;
    }

    for (int i = rows - 1; i >= 0; i--) {//根据行和列保存的信息设置每一个元素
        for (int j = cols - 1; j >= 1; j--)
            if (matrix[i][0] == 0 || matrix[0][j] == 0)
                matrix[i][j] = 0;
        if (col0 == 0) matrix[i][0] = 0;
    }
}
```


## 动态规划

### LeetCode5

#### 找到最长回文子字符串(LeetCode5:Longest Palindromic Substring)

* 描述：给出一个字符串，找出它的最长且为回文结构的子字符串：如：“babad”的最长子字符串且为回文的子串为"bab",或“aba”,而"cbbd"的最长子串为“bb”

思路1：暴力求解：找出所有可能的子字符串头i和尾j，然后判断是否为回文，复杂度O（N^3）

思路2: 动态规划，用一个二维数组arr记录子字符串是否为回文，横坐标纪录字符串开头i(i < s.zise()),纵坐标纪录结尾j(i<=j< s.size());然后二维数组中纪录的是从i到j的子字符串**是否为一个回文结构**。回文结构由以下三种情况

    * 由**一个字符**组成的回文字符串
    * 由**两个相同的字符**组成回文字符串
    * i到j字符串为回文字符串，则i+1到j也为回文字符串，且s[i] = s[j];

所以根据上述关系arr[i][j]和arr[i+1][j-1]的关系来做状态转换方程构建该二维数组。构建过程的复杂度为O(N^2),然后根据该二维数组找出最长子字符串。空间复杂度也为O(N^2)

思路3(中心扩展，时间复杂度O(N^2),空间复杂度O(1)): 回文结构其实就是以一个点为**中心**，向两边扩展，我们只要找到这**2n-1个中心**（n为字符串的长度）然后两边扩展即可得到回文长度即可。为什么是2n-1个中心，因为中心分为两种：

    * 以一个字符为中心
    * 以两个相同的字符为中心

{% highlight c++ %}
public String longestPalindrome(String s) {
    int start = 0, end = 0;
    for (int i = 0; i < s.length(); i++) {
        int len1 = expandAroundCenter(s, i, i);
        int len2 = expandAroundCenter(s, i, i + 1);
        int len = Math.max(len1, len2);
        if (len > end - start) {
            start = i - (len - 1) / 2;
            end = i + len / 2;
        }
    }
    return s.substring(start, end + 1);
}

private int expandAroundCenter(String s, int left, int right) {
    int L = left, R = right;
    while (L >= 0 && R < s.length() && s.charAt(L) == s.charAt(R)) {
        L--;
        R++;
    }
    return R - L - 1;
}
{% endhighlight %}

思路4（Manacher's Algorithm,O(N)）:

首先将每两个字符串中插入"#",确保每个回文字符串都是奇数形式，以一个字符为中心的回文字符串
```
＃1＃2＃2＃1＃2＃2＃
```
为了防止越界，我们还需要在首尾再加上非#号字符

遍历字符串，当遍历到第i字符时，我们需要在遍历过程中纪录回文串可以延伸到**最右端的端点下标max_right**,和以该端点作为结尾的回文字符串的**中心点ct**。还要纪录以该点为中心点的回文串的长度len[i]

* 假设当我们遍历到ct时，匹配后确定了以它为中心的回文串达到的**右端点为前面所有中心的回文串的最右端点**：max_right。
* 遍历下一个节点j = ct＋1时，len[j] = max_right < j ? min(p[2*ct-j],max_right - j):1;
    - 这个表达式的含义就是当这个下标还在我们前面遍历得到回文串的**最右端点的范围之内**时，根据回文串的映射关系：2*ct-j为j以ct为中心的**映射点**，在ct为中心的回文串范围中，j和2*ct-j的回文串长度应该保持一致，但是出了这个范围，就需要进一步匹配来确定:
    ![LeetCode_1.png](/img/LeetCode_1.png)
    - 遍历过程中需要纪录:回文串**最右端点及中心点**，最长回文字符串的**中心点及长度**。遍历一次更新一次
    - 代码参考：https://www.cnblogs.com/grandyang/p/4475985.html

### LeetCode10

#### 字符串匹配“.*”(LeetCode10:Regular Expression Matching)

题目链接： https://leetcode.com/problems/regular-expression-matching/description/
描述：给定一个字符串匹配模式pattern，输入一个字符串判断是否与该pattern匹配。

1. '.'代表任意字符
2. 'a*'代表a可以出现0次，1次或任意次
3. '.*'带表任意长度（包括0）任意类型的字符串

思路1：递归

处理这三种匹配情况
1. 碰到字母或'.'时，只要相等就进行下个字符的匹配
2. 碰到*时分两种情况

    * 字符＋‘*’匹配0个字符，1个字符或多个重复字符
    * '.*'匹配0个字符，1个任意字符或多个任意长度的任意类型的字符

{% highlight c++ %}
bool match(string & str,string & pattern,int str_i,int pat_i){
        if(str_i == str.size() && pat_i == pattern.size()){
                return true;
        }
        if(str_i>str.size())
            return false;
        bool result = false;
        if(pattern[pat_i+1]!='*'){
        /*处理非*的情况*/
            if(str[str_i] == pattern[pat_i]||pattern[pat_i] == '.')
                return match(str, pattern, str_i+1, pat_i+1);
            return result;
        }else {
            if(pattern[pat_i] != '.'){
            /*处理字符＋‘*’的情况*/
                result = match(str, pattern, str_i, pat_i+2);//字符＋‘*’匹配0个字符串
                if(result)
                    return result;
                if(str[str_i] == pattern[pat_i])
                    result = match(str, pattern, str_i+1, pat_i+2)||match(str, pattern, str_i+1, pat_i);//字符＋‘*’匹配1个字符串或多个重复字符
                return result;
            }else{
            /*处理‘.*’的情况*/
                result = match(str, pattern, str_i, pat_i+2)||match(str, pattern, str_i+1, pat_i+2)||match(str, pattern, str_i+1, pat_i);;//‘.*’匹配0个字符，1个字符，任意长度的任意类型的字符
                return result;
            }
        }
    };
}
{% endhighlight %}

思路2: 动态规划

用一个二维数组memo[pat_i+1][str_j+1]来记录长度为str_j和长度为pat_i的模版是否匹配
1. 先进行初始化
2. 状态转换方程

    * 碰到pattern[pat_i]为字母或‘.’时
    * 碰到pattern[pat_i]为为‘*’时
        - pattern[pat_i－1]为普通字符时
        - pattern[pat_i-1]为‘.’时
3. 返回memo[pat_i+1][str_j+1]

{% highlight c++ %}

bool match_dp(string & str,string & pattern){
        int str_size = (int)str.size(),pat_size = (int)pattern.size();
        bool ** memo =new bool*[pat_size+1];//二维数组的创建
        for(int i =0;i<=pat_size;i++){
            memo[i] = new bool[str_size+1];
        }
        for(int i = 0;i<=pat_size;i++)
            for(int j = 0;j<=str_size;j++)
                memo[i][j] = false;
        //Initialize初始化
        memo[0][0] = true;
        if(str_size>0&&pat_size>0){
            if(str[0] == pattern[0]||pattern[0] == '.')
                memo[1][1] = true;
        }
        if(pat_size<2){
            return memo[pat_size][str_size];
        }
        //Dynamic Programming，开始进行遍历
        bool result = false;
        for(int i = 2;i<=pat_size;i++)
        {
            for(int j = 0;j<=str_size;j++){
                result = false;
                if(pattern[i-1] == '*'){
                    if(pattern[i-2]!='.'){
                        result =result||memo[i-2][j];//字母＋*匹配0个字符
                        if(str[j-1] == pattern[i-2])
                            result = result || memo[i-2][j-1]||memo[i][j-1];//字母＋*匹配1个字符或多个字符
                    }else{
                    /* 处理情况‘.*’  */
                        result = memo[i][j-1]||memo[i-2][j];//.*匹配一个或多个字符，.*匹配0个字符
                    }
                }else{
                /* 处理情况‘非*’*/
                    if(str[j-1] == pattern[i-1]||pattern[i-1] == '.'){
                        result = memo[i-1][j-1];
                    }
                }
                memo[i][j] = result;
            }
        }
        return memo[pat_size][str_size];
    }

{% endhighlight %}

### LeetCode44

#### 字符串匹配："?*"(LeetCode44:Wildcard Matching)

描述：给定一个字符串匹配模式pattern，输入一个字符串判断是否与该pattern匹配。

'?'可以代替任意一个字符，'*'可以代替任意长度任意类型的字符串

方法有两种：
* 回溯法
* 动态规划二维数组
    - 优化版本：只用一维数组记录数据

{% highlight c++ %}

class Solution {
    
    public:
    //回溯法，比较耗时，递归调用
    bool isMatch(string s, string p) {
        int s_end = s.size();
        int p_end = p.size();
        return ismatch(s,p,0,0,s_end,p_end);
    }
    
    bool ismatch(string &s,string &p,int i,int j, int s_end,int p_end){
        bool result = false;
        if(i == s_end){
            if(j == p_end)
                return true;
            else if(p[j] == '*')
                return ismatch(s,p,i,j+1,s_end,p_end);
            else
                return false;
        }
        
        if(i>s_end || j>p_end)
            return false;
        if(j < p_end){
            if(p[j] == '?')
                result = ismatch(s,p,i+1,j+1,s_end,p_end);//匹配一个，均前进一步
            else if(p[j] == '*')
                result = ismatch(s,p,i,j+1,s_end,p_end)||ismatch(s,p,i+1,j+1,s_end,p_end)||ismatch(s,p,i+1,j,s_end,p_end);//'*'分别匹配0个，1个和多个
            else if(s[i] == p[j])
                result = ismatch(s,p,i+1,j+1,s_end,p_end);//匹配一个，均前进一步
            else
                result = false;
        }
        
        return result;
        
        
        
    }
    //二维数组进行动态规划
        bool isMatch_dp2(string s, string p) {
            const int s_end = s.size(),p_end = p.size();
            int** record = new int*[p_end+1];//二维数组纪录结果数据
            
            //初始化基础数据
            for(int i=0;i<=p_end;i++){
                record[i] = new int[s_end+1];
            }
            
            for(int i=0;i<=p_end;i++){
                for(int j = 0;j<=s_end;j++){
                    record[i][j] = 0;
                }
            }
            
            record[0][0] = true;
            if(p_end>0){
                //初始化基础数据
                if(p[0] == '*'){
                    for(int i = 0;i<=s_end;i++)
                        record[1][i] = 1;
                }else if(p[0] == '?'||p[0] == s[0]){
                    record[1][1] = 1;
                }
                
                for(int i = 0;i<p_end;i++)
                    if(p[i] == '*')
                        record[i+1][0] = record[i][0];
                
                //开始动态规划
                for(int i=2;i<=p_end;i++){
                    for(int j = 0;j<=s_end;j++){
                        if(p[i-1] == '*'){
                            for(int k = 0;k<=j;k++){
                                if(record[i-1][k])
                                    record[i][j] = 1;
                            }
                        }
                        else if(p[i-1] == '?'){
                            record[i][j] = record[i-1][j-1];
                        }else if(p[i-1] == s[j-1]){
                            record[i][j] = record[i-1][j-1];
                        }
                    }
                }
            }
            
            if(record[p_end][s_end]){
                return true;
            }
            else
                return false;
        }
    //一维数组进行动态规划
    bool isMatch_dp1(string s, string p) {
        int s_end = s.size(),p_end = p.size();
        int *record = new int[s_end+1];//用一维数组纪录结果
        record[0] = 1;
        if(s_end >0){//初始化基础数据
            for(int i = 1;i<s_end+1;i++){
                record[i] = 0;
            }
        }
        
        if(p_end>0){
            for(int i = 1;i<=p_end;i++){
                for(int j = s_end;j>=0;j--){//倒序进行确认
                    if(p[i-1] == '*'){
                        for(int k = 0;k<=j;k++){
                            if(record[k] == 1){
                                record[j] = 1;
                                break;
                            }
                        }
                    }
                    else if(p[i-1] == '?'){
                        record[j] = record[j-1];
                    }else if(p[i-1] == s[j-1]){
                        record[j] = record[j-1];
                    }else{
                        record[j] = 0;
                    }
                }
            }
        }
        
        return record[s_end];
    }


};


{% endhighlight %} 

### LeetCode38

#### 计数后用字符串表达（LeetCode38:Count and Say）

有一个字符串的序列，下一项为上一项的计数表达，从"1"开始计数

```
1. "1"
2. "11"  //1个1
3. "21"  //2个1
4. "1211"   //1个2，1个1
5. "111221"   //1个1，1个2，2个1
...
```

按照这个规律，求的第n项的字符串是什么

思路：动态规划，只需要一个字符串记录第n-1项字符串，然后开始计数后写入第n项字符串。

{% highlight c++ %}
class Solution {
public:
    string countAndSay(int n) {
        if(n<=0)
            return NULL;
        string record = "1";//用于记录上一项的字符串
        string tmp;//用于迭代得到本轮字符串
        int count;
        char num;
        if(n==1){
            return record;
        }
        for(int k = 1;k < n;k++){
            for(int i=0;i < record.size();i++){
                num = record[i];
                count = 0;
                while(i < record.size()&&record[i] == num){
                    count++;
                    i++;
                }
                i--;
                tmp.push_back(count+'0');
                tmp.push_back(num);
            }
            record = tmp;
            tmp.clear();
        }
        return record;
    }
};

{% endhighlight %}


### LeetCode53

#### 最大子序列和（LeetCode53:Maximum Subarray）

给一个数组，求出该数组中和最大的子序列。

思路：循环遍历数组，记录每一个数结尾的最大子序列和，当该**和小于0时重新从0开始求和**。遍历结束后获取最大的子序列和。

{% highlight c++ %}
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        if(nums.empty())
            return 0;
        int sum = 0,sum_max = nums[0];
        for(int i = 0;i<nums.size();i++){
            sum += nums[i];
            if(sum > sum_max)//寻找最大的子序列和
                sum_max = sum;
            if(sum < 0)//小于0时从0开始重新求和
                sum = 0;
        }
        
        return sum_max;
    }
};

{% endhighlight %}

### LeetCode62

#### 机器人走格子路径（LeetCode62：Unique Paths）

有一个mxn的棋盘，机器人要从起点(1,1)走到终点(m,n)， 且机器人只能向右前进和向下前进。问机器人一共有多少种方式，或有多少条不同的路径可以到达终点？

![robot_path](/img/robot_path.png)

```
Input: m = 3, n = 2
Output: 3
Explanation:
From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:
1. Right -> Right -> Down
2. Right -> Down -> Right
3. Down -> Right -> Right
```

思路1：回溯法，递归耗时

```c++
class Solution {
public:
    int uniquePaths(int m, int n) {
        int result = 0;
        int *result_ptr = &result;
        uniquePath_x(1,1,m,n,result_ptr);
        return result;
    }
    
    void uniquePath_x(int x, int y, int m, int n,int * count){
        if(x == m&&y==n ){
            *count +=1;
            return;
        }
        if(x < m )
            uniquePath_x(x+1,y,m,n,count);
        if(y < n )
        return;
    }
};
```

思路2:动态规划，用一维数组即可

```c++

class Solution {
public:
    int uniquePaths(int m, int n) {
        if(m<=0||n<=0)
            return 0;
        if(m == 1|| n == 1)
            return 1;
        int *record = (int *)malloc(m*sizeof(int));
        
        for(int i = 0;i<m;i++){
            record[i] = 1;
        }
        
        for(int i =1;i<n;i++)
            for(int j = 1;j<m;j++){
                record[j] = record[j-1]+record[j];
            }
        
        return record[m-1];
    }
    

};
```

## 递归

### LeetCode17

#### 手机号码的字符串组合（LeetCode17:Letter Combinations of a Phone Numbe）
按手机输入法的格式，输入一串数字，得到所有可能的字符串:
![leetcode_phonenum.png](/img/leetcode_phonenum.png)

简单的递归思路：需要注意的点就是传入参数时，传入引用可以节省大部分运行时间

代码:

{% highlight c++ %}
class Solution {
public:
    map<int,string> num_map = { {2,"abc"},{3,"def"},{4,"ghi"},{5,"jkl"},{6,"mno"},{7,"pqrs"},{8,"tuv"},{9,"wxyz"} };//关联容器的初始化
    
    vector<string> letterCombinations(string digits) {
        string str;
        vector<string> vs;
        if(digits.size() == 0)
            return vs;
        vs = letterCombinations_x(digits,vs,str,0,digits.size());
        return vs;
    }
    vector<string> &letterCombinations_x(string &digits,vector<string> & vs,string &str,int n,int size) {
        if(n == size){
            vs.push_back(str);
            return vs;
        }
        string num_str = num_map[digits[n]-'0'];
        for(int i=0;i<num_str.size();i++){
            string str_tmp = str;
            str_tmp.push_back(num_str[i]);
            letterCombinations_x(digits,vs,str_tmp,n+1,size);//开始递归
        }
        return vs;
    }
};

{% endhighlight%}

### LeetCode 46

#### 排列组合（LeetCode 46: Permutations）

给出一个整形数组，输出该整形数组的排列组合：

思路：将首元素和所有的元素（包括它自己）进行交换后，递归求解剩余元素的排列组合，具体思路可以见剑指offer的面试题38，字符串的排列组合。

{% highlight c++%}

class Solution {
public:
    vector<vector<int>> permute(vector<int>& nums) {
         vector<vector<int>> result;
        if(nums.empty()){
            return result;
        }
        int start = 0,end = nums.size()-1;
        permute_x(start,end,nums,result);
        return result;
        
    }
    
    void permute_x(int start,int end,vector<int>& vec,vector<vector<int>>& result ){
        if(start == end){
            result.push_back(vec);
            return;
        }
        
        for(int i = start;i<=end;i++){
            vector<int> vec1 = vec;
            int tmp = vec1[start];//首元素和其余元素交换后
            vec1[start] = vec1[i];
            vec1[i] = tmp;
            permute_x(start+1,end,vec1,result);//递归进行排列组合
        }
        
        return;
        
    }
    
};

{% endhighlight %}

### LeetCode48

#### n x n矩阵的旋转（LeetCode48: Rotate Image）

给一个nxn矩阵matrix，输出它向右旋转90度的新的nxn矩阵：

```
如input matrix = 
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
]
输出：
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]
```

思路：将外围的部分进行旋转后，剩下的部分依然是一个(n-2)x(n-2)的矩阵，递归求解

{% highlight c++ %}
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        if(matrix.empty()){
            return;
        }
        int size = matrix[0].size();
        rotate_x(matrix,size,size);
    }
    
    void rotate_x(vector<vector<int>>& matrix,int n,int size){
        if(n==0||n==1){
            return;
        }
        int start = (size-n)/2;
        int end = start+n-1;
        //将外围进行旋转操作
        for(int i = 0;i<n-1;i++){
            int tmp = matrix[start][start+i];
            matrix[start][start+i] = matrix[end-i][start];
            matrix[end-i][start] = matrix[end][end-i];
            matrix[end][end-i] = matrix[start+i][end];
            matrix[start+i][end] = tmp;
        }
        //递归求解更小规模的矩阵
        rotate_x(matrix,n-2,size);
    }
};

{% endhighlight %}


### LeetCode54

#### 旋转打印矩阵（LeetCode54：Spiral Matrix）

给一个mxn二维矩阵,顺时针的顺序将所有元素打印出来：

```
Input:
[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]
Output: [1,2,3,6,9,8,7,4,5]

Input:
[
  [1, 2, 3, 4],
  [5, 6, 7, 8],
  [9,10,11,12]
]
Output: [1,2,3,4,8,12,11,10,9,5,6,7]
```

思路：递归，每次打印分为四个步骤：横向，纵向，再横向逆序，纵向逆序，然后递归打印剩余部分，依然是一个矩形。

注意：需要考虑最小问题的求解

1. 高为1的矩形打印，只需要一部
2. 长度为1的矩形打印，只需要一步
3. 高为2的矩形打印，只需要三部

```c++

class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        vector<int> result;
        if(matrix.empty())
            return result;
        int height = matrix.size()-1;
        int len = matrix[0].size()-1;
        spiralOrder_x(matrix,0,len,height,result);
        return result;
        
    }
    
    void spiralOrder_x(vector<vector<int>>& matrix , int n, int len, int height , vector<int>& result){
        
        if(n>len/2 || n>height/2)
            return;
        int start_i = n,start_j = n,end_i = height - n,end_j = len - n;
        if((height - 2*n + 1)==1){//子问题1
            for(int j = start_j;j<=end_j;j++)
                result.push_back(matrix[start_i][j]);
            return;
        }
        
        if((len -2*n + 1) == 1){//子问题2
            for(int i = start_i;i<=end_i;i++){
                result.push_back(matrix[i][end_j]);
            }
            return;
        }
        
        if((height-2*n +1) == 2){//子问题3
            for(int j =start_j;j<=end_j;j++)
                result.push_back(matrix[start_i][j]);
            result.push_back(matrix[start_i+1][end_j]);
            for(int j = end_j-1;j>=start_j;j--)
                result.push_back(matrix[end_i][j]);
            return;
        }
        //常规四步打印
        for(int j = start_j;j<=end_j;j++)
                result.push_back(matrix[start_i][j]);
        for(int i = start_i+1;i<=end_i;i++)
            result.push_back(matrix[i][end_j]);
        for(int j = end_j-1;j>=start_j;j--)
            result.push_back(matrix[end_i][j]);
        for(int i = end_i-1;i>start_i;i--)
            result.push_back(matrix[i][start_j]);
        
        spiralOrder_x(matrix,n+1,len,height,result);//递归打印小规模矩形
        
    }
};

```
## 位运算,数学边界问题

### LeetCode7

#### 整型数反转(LeetCode7:Reverse Integer)

将一个整型数的高位和低位进行反转，负数不变号，如果一个整型数反转后溢出后则返回0:

例子：
* 123  ＝》321
* －12 ＝》－21
* －120 ＝》－21

注意点：

* 整型数的范围为 **[-2^31,2^31-1];所以可能出现－2^31在范围内，而它的绝对值却不在整型范围内**
* 要计算2^31次方：long upper = **(2L<<31);//L不能掉**

{% highlight c++ %}
class Solution {
public:
    int reverse(int x) {
        bool positive = true;
        long x2 = (long)x;
        long upper = (2L<<30)-1;
        //处理正负号
        if(x2<0){
            positive = false;
            upper = upper-1;
            x2 = labs(x2);//这里不能用abs，abs无法处理-2^31的绝对值，因为它处理整型数，转换过来的正数会溢出
        }
        if(x2 == 0)
            return 0;
        //处理末端为0的情况
        while(!(x2%10))
            x2 /= 10;
        vector<long> digit;
        while(x2>=10)
        {
            digit.push_back(x2%10);
            x2 = (x2-x2%10)/10;
        }
        digit.push_back(x2);
        long result = 0;
        for(int k = 0;k<digit.size();k++){
            result = result*10 + digit[k];
            if(result>upper){
                return 0;
            }
        }
        if(positive)
            return result;
        else
            return -result;
    }
};
{% endhighlight %}

### LeetCode29

#### 两个整型数做除法，不使用乘除运算符(LeetCode29:Divide Two Integers)

给两个整数相除，得到除数，但不能使用乘除运算符

要求：

1. 除数和被除数都是32位的整型数
2. 除数不能为0
3. 整型数的范围为：**[-2^31,2^31-1]**,当相除后的结果溢出时，返回2^31-1

思路：使用位运算，逐个将结果中的每一位（二进制位）数求出。将除数向左<<逐个移位与被除数进行比较。

{% highlight c++ %}
class Solution {
public:
    int divide(int dividend, int divisor) {
        //处理边界问题
        long int_max = (2L<<30)-1,int_min = -(2L<<30);
        if(dividend == int_min && divisor == -1){
            return int_max;
        }
        
        long tmp ,res = 0,res_tmp = 0;
        //判断正负号
        bool positive = true;
        if((dividend > 0 && divisor<0)||(dividend < 0 && divisor > 0)){
            positive = false;
        }
        long divd = labs((long)dividend);
        long divs = labs((long)divisor);
        
        
        while(divd>=divs){
            tmp = divs;
            res_tmp = 1;
            while(divd >= (tmp <<= 1))
            {
                res_tmp <<= 1;
            }
            divd -= tmp >> 1;//循环一次，被除数减去一次移位后的除数
            res += res_tmp;
        }
        if(positive)
            return res;
        else
            return -res;
    }
};
{% endhighlight %}

### LeetCode50

### 求幂myPow()(LeetCode50: Pow(x, n))

题目要求：实现pow(x,n)

* -100.0 < x < 100.0
* n 是一个32位有符号整数。

```
Input: 2.00000, -2
Output: 0.25000
Explanation: 2-2 = 1/22 = 1/4 = 0.25
```

思路：扫描n的二进制上的为1的bit,来计算幂的结果，例如：n为139，则其二进制为10001011，那么x^n == x^(1+2+8+128) == (x^1) * (x^2) * (x^8) * (x^128)

PS:需要考虑的特殊情况

1. x取值为0时，0的正数次幂是1，而负数次幂是没有意义的；判断x是否等于0不能直接用“==”。
2. 对于n取值INT_MIN时，**-n并不是INT_MAX**，这时需要格外小心。
3. 尽量使用**移位运算来代替除法运算**，加快算法执行的速度。

判断double变量是否为零是否正确的题目。判断double变量是否为零 **不能像我们直观想象的那样double d;if( d == 0 );**这种做法是极其错误的,因为double是双精度的，他表示本身就是有精度误差的，所以这样判断零不正确。应正确步骤应该是先 **定义一个精度范围**，当double小于该精度范围时就可以判定double变量是否为0了。代码如下：

```
#define MIN_VALUE 1e-8
#define IS_DOUBLE_ZERO(d)  (abs(d) < MIN_VALUE)
```

代码：

{%highlight c++%}
class Solution {
public:
    double myPow(double x, int n) {
        if(n<0){
            if(n == INT_MIN)
                return 1/(myPow(x,INT_MAX)*x);
            else
                return 1/myPow(x,-n);
        }
        double ans = 1;
        if(n>0){
            while(n!=0){
                if(n&1) //只在bit为1的位乘如到结果中去
                    ans *= x;
                x *=x;
                n >>=1;
            }
        }
        
        return ans;
    }
};

{% endhighlight %}

### LeetCode69

#### 求平方根（LeetCode69:Sqrt(x)）

如题，给出一个数，求它的平方根，若平方根不为整数，则返回小于该平方根的最大的整数。

思路：二分法求值

注意特殊情况：

1. 乘以2时可以用位运算替代
2. 注意二分法求平方根的过程中，可能出现有的**数的平方大于整型数的最大可能的值INT_MAX**，所以应该用long 来保存临时结果。

```c++
class Solution {
public:
    int mySqrt(int x) {
        if (x==0)
            return 0;
        long pre = 1, back = 1;
        long tmp = 1;//用long保存临时结果
        while(tmp < x){
            pre = back;
            back <<= 1;//位运算替代乘以2
            tmp =back*back;
        }
        long mid;
        while(pre <= back){// 二分法求值
            mid = (pre+back)/2;
            tmp = mid*mid;
            if(tmp > x)
                back = mid - 1;
            else if(tmp < x )
                pre = mid + 1;
            else
                return mid;
        }
        if(pre*pre>x)
            return pre-1;
        else
            return pre;
    }
};
```


## 数据分类

### LeetCode49

#### 字符串分类(LeetCode49：Group Anagrams)

给一个数组，将所有字符相同的字符串分到一个数组里面去

```
Input: ["eat", "tea", "tan", "ate", "nat", "bat"],
Output:
[
  ["ate","eat","tea"],
  ["nat","tan"],
  ["bat"]
]
```

思路：利用unordered_map(**哈希表**)**索引**的性质，先将所有字符串**进行排序**，排序后一样的字符串放到一个数组。

{% highlight c++ %}
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        vector<vector<string>> result;
        if(strs.empty()){
            return result;
        }
        unordered_map<string,vector<string>> diff;
        for(int i= 0 ;i<strs.size();i++){
            string sorted_str = strs[i];
            sort(sorted_str.begin(),sorted_str.end());//对字符串进行排序
            if(diff.count(sorted_str)){//查看当前map中有没有出现过该索引
                diff[sorted_str].push_back(strs[i]);
            }else{
                vector<string> new_vec;
                new_vec.push_back(strs[i]);
                diff.insert(make_pair(sorted_str,new_vec));
            }
        }
        
        for(auto pair : diff){//map遍历的方法
            result.push_back(pair.second);
        }
        
        return result;
    }
};
{% endhighlight %}

## 其它

### LeetCode11

#### 装水最多的容器(LeetCode11:Container with most water)

描述：给定一个整型数组｛a1,a2,a3...an｝;这些点代表在坐标轴上的n个点，（i，ai）。根据这些点画出垂直于x轴的直线，这些直线中任取两条直线构成一个容器，求两条直线使得构成的容器可以装水的体积最大。

![container_water](/img/container_water.png)

如图灰色部分就是两条加粗的线构成容器的所装水的容量。

思路：两点法，从两端开始front =1 ,back = end,构成容器的大小为size,只要比较这两条直线的长度，在front和back的范围里想要**找到另一条线**和这两条线其中一条构成的容器大于size,则只能和**较长的一端**进行组合，所以我们将**较短的一端向中间移动**找到一条比它长的直线作为容器的一端，然后计算容器大小，如此循环移动直到front和back重合,在这个过程中**记录容器容量的最大值**。

[解法链接](https://leetcode.com/problems/container-with-most-water/solution/)

代码参考：

{% highlight c++%}

class Solution {
public:
    int maxArea(vector<int>& height) {
        if(height.empty()||height.size()==1){
            return 0;
        }
        int front = 0,back = height.size()-1;
        int max_size = (height[back]>height[front]?height[front]:height[back])*(back-front);
        //移动直到两端重合
        while(front<back){
            int front_tmp = front;
            int back_tmp = back;
            int h = 0;
            //向中间移动较短的一端
            if(height[front]>=height[back]){
            //将尾端向前移动
                while(height[back_tmp] >= height[back] && back>front)
                    back--;
                if(height[back_tmp]<height[back]){
                //计算容器大小，记录最大容器容量
                    h = height[back]>height[front]?height[front]:height[back];
                    max_size = h*(back-front)>max_size?h*(back-front):max_size;
                }
                    
            }else{
            //将首段向后移动
                while(height[front_tmp] >= height[front] && back>front)
                    front++;
                if(height[front_tmp] < height[front]){
                    h = height[back]>height[front]?height[front]:height[back];
                    max_size = h*(back-front)>max_size?h*(back-front):max_size;
                }
            }
            
        }
        
        return max_size;
        
    }
};
{% endhighlight %}


### LeetCode42

#### 计算容器可以装多少水(LeetCode42:Trapping Rain Water)

描述：给出一个整形数数组，每个数代表一个柱子，柱子的宽度为1，两根柱子之间可以装水，问该数组中的所有数字构成的所有柱子能装多少水？

![rainwatertrap](/img/rainwatertrap.png)

如上图，给出数组[0,1,0,2,1,0,1,3,2,1,2,1],输出：6（装水的容量）

我的解法：笨拙复杂，使用两个栈，一个栈记录高度，一个栈记录该减去的水的容量，其实和标准的使用栈解法的思路类似，只不过思路过于复杂。

* 我的思路和标准解法的思路都是求两根柱子，超出其他矮柱子的高度的部分装的水的容量，这部分的水就只和这两根柱子相关，和其他的柱子没有关系，所以就不会导致重复计算。
    - 但我的思路是先求两根柱子所能装的水的最大容量，然后减去两根柱子中间被其他柱子所影响的容量，这就比较复杂
    - 标准解法的思路就比较直接，直接求超出的高度，计算只与这两根柱子相关的水容量

{% highlight c++ %}
class Solution{
    public:
    int trap(vector<int>& height) {
        if(height.empty()||height.size()==1){
            return 0;
        }
        
        stack<pair<int, int>> height_stack;
        stack<int>  minus_stack;
        int water_tmp = 0,water_sum = 0,water_max = 0;
        int minus_tmp = 0;
        
        for(int i = 0;i< height.size();i++){
            if(height[i]!=0){
                if(height_stack.empty()){
                
                    height_stack.push(make_pair(height[i], i));
                    minus_stack.push(0);
                }else{
                    while(!height_stack.empty()){
                        pair<int, int> pair_tmp = height_stack.top();
                        if(pair_tmp.first > height[i]){
                            minus_tmp = minus_stack.top();
                            water_tmp = height[i]*(i-pair_tmp.second-1)-minus_tmp;
                            water_sum += water_tmp;
                            minus_tmp +=water_tmp;
                            minus_stack.pop();
                            minus_stack.push(minus_tmp);
                            break;
                        }
                        minus_tmp = minus_stack.top();
                        water_tmp = pair_tmp.first*(i-pair_tmp.second-1)-minus_tmp;//只与目前的两根柱子相关的水容量
                        water_max = water_tmp + minus_tmp;
                        water_sum += water_tmp;
                        height_stack.pop();
                        minus_stack.pop();
                        if(!height_stack.empty()){
                            minus_tmp = minus_stack.top();
                            minus_stack.pop();
                            minus_tmp = minus_tmp + water_max + pair_tmp.first;
                            minus_stack.push(minus_tmp);
                        }
                    }
                    height_stack.push(make_pair(height[i], i));
                    minus_stack.push(0);
                }
            }
        }
        
        return water_sum;
    }
};


{% endhighlight %}

* 思路1: 标准的栈解法：

{% highlight c++ %}

int trap(vector<int>& height)
{
    int ans = 0, current = 0;
    stack<int> st;
    while (current < height.size()) {
        while (!st.empty() && height[current] > height[st.top()]) {
            int top = st.top();
            st.pop();//当压入一个数时，会把所有小于该数的数全部弹出栈
            if (st.empty())
                break;
            int distance = current - st.top() - 1;
            int bounded_height = min(height[current], height[st.top()]) - height[top];//求超出的高度部分，必须有三个数参数，两个相邻的数是无法装水的
            ans += distance * bounded_height;//直接计算超出的高度部分所装的水容量
        }
        st.push(current++);
    }
    return ans;
}

{% endhighlight %}

* 思路2: 计算每一根柱子的顶部空间有多少会被淹没在水里，这样计算每根柱子顶部被淹没在顶部的空间，然后累加起来就是整个水的容量。

    - 解法1:暴力计算，为每根柱子计算左右两边的最高的高度，然后用左右最高高度中的较小者减去该柱子的高度，就是该柱子顶部被淹没的空间
    - 解法2:动态规划，先记录每根柱子的左右最高高度到两个vector中，这样可以避免重复计算。

{% highlight c++ %}
//解法1:
int trap(vector<int>& height)
{
    int ans = 0;
    int size = height.size();
    for (int i = 1; i < size - 1; i++) {
        int max_left = 0, max_right = 0;
        for (int j = i; j >= 0; j--) { //Search the left part for max bar size
            max_left = max(max_left, height[j]);
        }//计算左边的最高高度
        for (int j = i; j < size; j++) { //Search the right part for max bar size
            max_right = max(max_right, height[j]);
        }//计算右边的最高高度
        ans += min(max_left, max_right) - height[i];//累加每根柱子顶部别淹没的空间
    }
    return ans;
}

//解法2:

int trap(vector<int>& height)
{
    if(height == null)
        return 0;
    int ans = 0;
    int size = height.size();
    vector<int> left_max(size), right_max(size);
    left_max[0] = height[0];
    for (int i = 1; i < size; i++) {
        left_max[i] = max(height[i], left_max[i - 1]);
    }//记录每根柱子左边的最高高度到left_max
    right_max[size - 1] = height[size - 1];
    for (int i = size - 2; i >= 0; i--) {
        right_max[i] = max(height[i], right_max[i + 1]);
    }//记录每根柱子右边的最高高度到right_max
    for (int i = 1; i < size - 1; i++) {
        ans += min(left_max[i], right_max[i]) - height[i];//累加每根柱子顶部被淹没的部分
    }
    return ans;
}
{% endhighlight %}

思路三：两点法，从两端找到左边最大的和右边最大的，然后两端向中间移动，遇到短的就可以计算水的容量。https://leetcode.com/problems/trapping-rain-water/solution/

{% highlight c++ %}
int trap(vector<int>& height)
{
    int left = 0, right = height.size() - 1;
    int ans = 0;
    int left_max = 0, right_max = 0;
    while (left < right) {
        if (height[left] < height[right]) {
            height[left] >= left_max ? (left_max = height[left]) : ans += (left_max - height[left]);
            ++left;
        }
        else {
            height[right] >= right_max ? (right_max = height[right]) : ans += (right_max - height[right]);
            --right;
        }
    }
    return ans;
}

{% endhighlight %}

### LeetCode13

#### 罗马数转化为整数（LeetCode13:Roman to Integer）

```
Symbol       Value
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
```
如上所示，罗马表示数字的字符一一对应，数字规则如下：

* 规则1:较小字符可以放在较大字符前面构成一个数：如IX(10-1 = 9),XLC(100-50-10 = 40)
* 规则2:将一串罗马字符串根据规则1得到若干数字然后进行相加如：“MCMXCIV”,得到数字： M=1000,CM=900,XC=90,IV=4。最后相加结果为：1000+900+90+4 ＝ 1994

思路1：从正面将所有数字分开，然后再一个个相加

{% highlight c++%}
class Solution {
public:
    int romanToInt(string s) {
        if(s.empty())
            return 0;
        int result = 0;
        map<char,int> roman;
        roman['I'] = 1;
        roman['V'] = 5;
        roman['X'] = 10;
        roman['L'] = 50;
        roman['C'] = 100;
        roman['D'] = 500;
        roman['M'] = 1000;
        
        int num = roman[s[0]];
        int size = s.size();
        for(int i = 1;i<size;i++){
            //分割字符串得到数字
            while(i < size && roman[s[i]] >= roman[s[i-1]]){
                if(roman[s[i]] == roman[s[i-1]]){
                    num += roman[s[i]];
                }else{
                    num = roman[s[i]] - num;
                }
                i++;
            }
            //将得到的数字相加
            result+=num;
            num = 0;
            
            if(i<size){
                num = roman[s[i]];
            }
        }
        if(num != 0)
            result+=num;
        return result;
    }
};
{% endhighlight %}

思路2:从反方向来进行遍历，因为字符串构成数字的方向也是从后到前构成的：只有当后面的字符大于前面时才能构成一个数字。
{% highlight c++%}
int romanToInt(string s) 
{
    unordered_map<char, int> T = { { 'I' , 1 },
                                   { 'V' , 5 },
                                   { 'X' , 10 },
                                   { 'L' , 50 },
                                   { 'C' , 100 },
                                   { 'D' , 500 },
                                   { 'M' , 1000 } };
                                   
   int sum = T[s.back()];
   //从后向前遍历即可
   for (int i = s.length() - 2; i >= 0; --i) 
   {
       if (T[s[i]] < T[s[i + 1]])
       {
           sum -= T[s[i]];
       }
       else
       {
           sum += T[s[i]];
       }
   }
   
   return sum;
}
{% endhighlight %}

### LeetCode15

#### 三个数相加为0(LeetCode15:3Sum)

给定一个数组，从中找到所有可能的三元组，使得这三个加起来的总和为0。

思路1（暴力求解）:首先将数组进行排序，然后**三次循环**遍历确定找到使和为0的三元组。
    - 优化：最后一次循环可以用**关联容器**来确定，将所有的数据放到一个关联容器multiset,在前两次循环后，三元组中的第三个数也就可以确定下来，我们可以直接判断该数是否在multiset存在

**代码见LeetCode15.3Sum**


思路2（O(N^2)）:同样需要先将数组进行排序，然后确定三元组中的**第一个元素**（一次循环），然后我们可以知道后两个元素的和，然后利用**两点法（见剑指offer面试题57:和为s的数字）**,来确定后两个元素的值。

代码（Java）:
{% highlight java%}
public List<List<Integer>> threeSum(int[] num) {
    Arrays.sort(num);
    List<List<Integer>> res = new LinkedList<>(); 
    for (int i = 0; i < num.length-2; i++) {
        if (i == 0 || (i > 0 && num[i] != num[i-1])) {
            int lo = i+1, hi = num.length-1, sum = 0 - num[i];
            while (lo < hi) {
                if (num[lo] + num[hi] == sum) {
                    res.add(Arrays.asList(num[i], num[lo], num[hi]));
                    while (lo < hi && num[lo] == num[lo+1]) lo++;
                    while (lo < hi && num[hi] == num[hi-1]) hi--;
                    lo++; hi--;
                } else if (num[lo] + num[hi] < sum) lo++;
                else hi--;
           }
        }
    }
    return res;
}
{% endhighlight %}

### LeetCode22

#### 产生所有可能的有效括号组合（LeetCode22:Generate Parentheses）

题目描述：给定一个数字n，给出n个括号所有有效的组合方式。如给定3，则输出结果是：

```
[
  "((()))",
  "(()())",
  "(())()",
  "()(())",
  "()()()"
]
```

回溯法：见剑指offer中机器人的运动范围，这个题目也可以用一样的思路来考虑:

![tracing_back.png](/img/tracing_back.png)

和机器人走格子类似，横坐标是'('的已使用个数，纵坐标是')'的已使用个数，机器人走到的每一个格子都必须满足横坐标x>=纵坐标y。求有多少条路径满足从start走到end格子。

回溯法和递归的区别：

* 回溯不断调用自身，调用到最后即得到问题的答案。(将问题不断深入，穷尽每一种可能)
* 递归则是不断调用自身，直到最小问题得到解决后，在通过**不断返回**解决大问题，返回到第一次调用的函数才得到答案。（将问题不断分解，解决最小问题，再逐个解决大问题，最后得到整个问题的答案。）

本题代码：
{% highlight c++ %}

class Solution {
public:
    vector<string> generateParenthesis(int n) {
        string str = "(";
        vector<string> result;
        generateParenthesis_x(result,n-1,n,str);
        return result;
        
    }
    
    void generateParenthesis_x(vector<string> & vec,int s_count,int e_count,string &str){
        if(s_count<e_count&&s_count>0){//两个方向
            string tmp1 = str;
            tmp1.push_back('(');
            generateParenthesis_x(vec,s_count-1,e_count,tmp1);
            string tmp2 = str;
            tmp2.push_back(')');
            generateParenthesis_x(vec,s_count,e_count-1,tmp2);
            return;
        }else if(s_count<e_count&&s_count==0){//一个方向
            string tmp3 = str;
            tmp3.push_back(')');
            generateParenthesis_x(vec,s_count,e_count-1,tmp3);
        }else if(s_count==e_count&&s_count>0){//一个方向
            string tmp4 = str;
            tmp4.push_back('(');
            generateParenthesis_x(vec,s_count-1,e_count,tmp4);
        }else{
            vec.push_back(str);//走到end
        }
        
    }
};

{% endhighlight %}

### LeetCode23

#### 合并k个排序链表（LeetCode23: Merge k Sorted Lists）

将k个排序链表合并成一个排序链表：

```
Input:
[
  1->4->5,
  1->3->4,
  2->6
]
Output: 1->1->2->3->4->4->5->6
```
解决方法：https://leetcode.com/problems/merge-k-sorted-lists/solution/

思路1：用优先级队列，或红黑树实现的multimap结构保存每条链表的第一个元素，然后从这些元素中获取最小值（基于multimap或优先级队列很容易实现）插入新的链表。

PS:注意当创建来的链表为空时的处理

代码：

{% highlight c++ %}
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        multimap<int,ListNode*> first_map;
        ListNode* new_list = NULL;
        ListNode* cur= NULL;
        ListNode* cur_ptr = NULL;
        for(int i=0;i<lists.size();i++){
            if(lists[i]!=NULL)
                first_map.insert(make_pair(lists[i]->val,lists[i]));
        }
        //初始化链表头
        if(!first_map.empty()){
            auto iter0 = first_map.begin();
            new_list = cur = new ListNode(iter0->first);
            cur_ptr = iter0->second;
            first_map.erase(iter0);
            if(cur_ptr->next!=NULL){
                first_map.insert(make_pair(cur_ptr->next->val,cur_ptr->next));
        }
        //每获取一个最小值，需要将对应链表下一个最小值添加到map中来
        while(!first_map.empty()){
            auto iter = first_map.begin();
            ListNode *tmp = new ListNode(iter->first);
            cur->next = tmp;
            cur = tmp;
            cur_ptr = iter->second;
            first_map.erase(iter);
            if(cur_ptr->next!=NULL){
                first_map.insert(make_pair(cur_ptr->next->val,cur_ptr->next));
            }
            
        }
        }
        
        return new_list;
    }
};
{% endhighlight %}

思路2:暴力求解，逐个将两条链表合并成一条，直到所有链表都被合并

思路3:归并法，将所有链表分为两两一组，然后合并之后，继续分组合并。。直到最后合并成一条链表

### LeetCode55

#### 跳跃游戏（LeetCode55: Jump Game）

给一个非负数组，每个元素中的数值代表可以向前跳跃的最大步数，从第一个元素开始起跳，在每个元素的跳跃步数的限制下问能否跳到最后一格。

```
Input: [2,3,1,1,4]
Output: true
Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.
```

思路1：关注为0的元素，因为只要不能到达，肯定是有一个**跳跃步数为0的元素**限制了向前跳跃的步伐。所以我们遍历该数组，并记录遍历到当前元素可以到达的**最远距离**，只要遇到0时，判断当前可以到达的距离**是否可以越过该0节点**。不能越过则说明无法到达终点。

需要注意的特殊情况：0点出现在数组的**最后一个元素**上。

思路2:动态规划，可以实现但较复杂

思路1的代码实现：
```
class Solution {
public:
    bool canJump(vector<int>& nums) {
        if(nums.empty()||nums.size() == 1){
            return true;
        }
        bool success = true;//最远距离
        int max_reach = 0,cur_reach = 0;
        int len = nums.size();
        for(int i = 0;i<len;i++){
            if(nums[i]==0 && max_reach<=i && i!=len-1){//遇到0时，判断是否可以越过，并判断是否为最后一个元素
                success = false;
                break;
            }
            cur_reach = i+nums[i];
            if(cur_reach > max_reach)
                max_reach = cur_reach;//更新可以到达的最远距离
        }
        
        return success;
        
    }
};
```


### LeetCode56

#### 区间合并(LeetCode56: Merge Intervals)

给出一个区间数组，将所有具有重叠情况的数组合并到一个数组，再输出一个没有重叠现象的数组

```
Input: [[1,3],[2,6],[8,10],[15,18]]
Output: [[1,6],[8,10],[15,18]]
Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].

Input: [[1,4],[4,5]]
Output: [[1,5]]
Explanation: Intervals [1,4] and [4,5] are considerred overlapping.
```

思路：先排序，再逐个进行合并。

注意：尾部的处理，不能忘记最后一个区间的处理

```c++
/**
 * Definition for an interval.
 * struct Interval {
 *     int start;
 *     int end;
 *     Interval() : start(0), end(0) {}
 *     Interval(int s, int e) : start(s), end(e) {}
 * };
 */
class Solution {
public:
    vector<Interval> merge(vector<Interval>& intervals) {
        vector<Interval> result;
        if(intervals.empty()){
            return result;
        }
        
        multimap<int,Interval> in_map;
        int size = intervals.size();
        for(int i = 0;i<size;i++){
            in_map.insert(make_pair(intervals[i].start,intervals[i]));//插入到红黑树机制的multimap结构中进行排序
        }
        
        Interval *cur = &((*(in_map.begin())).second);
        for(auto iter = in_map.begin();iter!=in_map.end();iter++){
            if(iter->second.start <=cur->end)//逐个进行合并操作
                cur->end = iter->second.end>cur->end?iter->second.end:cur->end;
            else{
                result.push_back(*cur);//合并失败则说明再没有重叠的区间，直接压入结果数组
                cur = &(iter->second);       
            }
        }
        result.push_back(*cur);//尾部的处理
        return result;
        
    }
};
```


### LeetCode75

#### 颜色排序（LeetCode75:Sort Colors）

给一个数组，其中只有三类颜色：0代表红色，1代表黄色，2代表蓝色。将这数组中的颜色按0，1，2的顺序进行排序，将相同的颜色放在一起。

```
Input: [2,0,2,1,1,0]
Output: [0,0,1,1,2,2]
```

要求：使用一次遍历和常数空间复杂度完成排序

思路：两点法，将0放在首端，2放在尾端，自然1就在中间部分

```c++
class Solution {
public:
    void sortColors(vector<int>& nums) {
        int start = 0,end = nums.size()-1;
        int tmp;
        for(int i = 0;i <= end;i++){
            if(nums[i] == 0)//将0放在首端
            {
                tmp = nums[start];
                nums[start] = 0;
                nums[i] = tmp;
                start++;
            }
            
            if(nums[i] == 2){//将2放在尾端
                tmp = nums[end];
                nums[end] = 2;
                nums[i] = tmp;
                end--;
                i--;//和尾部数据进行交换时还要再检测一次
            }
        }
    }
};
```

